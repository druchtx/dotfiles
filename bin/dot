#!/usr/bin/env python3
"""
dot - Symlink-based dotfiles manager
Simple, fast, and maintainable
"""

import sys
import os
import json
import shutil
import argparse
import re
from pathlib import Path
from enum import Enum
from typing import List, Dict, Optional, Set, Tuple
from dataclasses import dataclass

# Prevent __pycache__ generation
sys.dont_write_bytecode = True

# ==============================================================================
# UI Functions
# ==============================================================================


def _color(text: str, code: str) -> str:
    """Add color if stdout is TTY"""
    if not sys.stdout.isatty():
        return text
    return f"\033[{code}m{text}\033[0m"

def green(text: str) -> str: return _color(text, "92")
def yellow(text: str) -> str: return _color(text, "93")
def red(text: str) -> str: return _color(text, "91")
def blue(text: str) -> str: return _color(text, "94")
def cyan(text: str) -> str: return _color(text, "96")
def dim(text: str) -> str: return _color(text, "2")
def bold(text: str) -> str: return _color(text, "1")


# ==============================================================================
# Data Models
# ==============================================================================


class LinkStatus(Enum):
    """Symlink status"""

    OK = "ok"  # Symlink exists and points to correct target
    MISSING = "missing"  # Symlink doesn't exist
    BROKEN = "broken"  # Symlink exists but target is missing
    CONFLICT = "conflict"  # Path exists but is not a symlink


@dataclass
class DotfileEntry:
    """Dotfile configuration entry"""

    source: str  # Relative to dotfiles dir
    target: str  # Absolute or ~/ path
    type: str  # "file" or "dir"
    template: bool = False  # Is this a template file


# ==============================================================================
# Template Manager
# ==============================================================================


class TemplateManager:
    """Manage template files and .dotenv"""

    PATTERN = re.compile(r"#\{([A-Z][A-Z0-9_]*)\}")

    def __init__(self, dotfiles_dir: Path):
        self.dotfiles_dir = dotfiles_dir
        self.dotenv_path = dotfiles_dir / ".dotenv"

    def scan_templates(self) -> Set[str]:
        """Scan all *.example files for #{VAR} placeholders"""
        variables = set()

        for example_file in self.dotfiles_dir.rglob("*.example"):
            try:
                content = example_file.read_text()
                matches = self.PATTERN.findall(content)
                variables.update(matches)
            except Exception:
                pass

        return variables

    def load_dotenv(self) -> Dict[str, str]:
        """Load existing .dotenv variables"""
        if not self.dotenv_path.exists():
            return {}

        env_vars = {}
        try:
            with open(self.dotenv_path) as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith("#") and "=" in line:
                        key, value = line.split("=", 1)
                        env_vars[key.strip()] = value.strip()
        except Exception:
            pass

        return env_vars

    def update_dotenv(self, variables: Set[str]) -> int:
        """Add missing variables to .dotenv, return count of added"""
        existing = set(self.load_dotenv().keys())
        missing = variables - existing

        if not missing:
            return 0

        # Append missing variables
        with open(self.dotenv_path, "a") as f:
            if self.dotenv_path.exists() and self.dotenv_path.stat().st_size > 0:
                f.write("\n")

            f.write("# Auto-generated from templates\n")
            for var in sorted(missing):
                f.write(f"{var}=\n")

        return len(missing)

    def render_template(self, source: Path) -> Optional[Path]:
        """Render template file, return generated file path"""
        if not source.name.endswith(".example"):
            return None

        # Load environment variables
        env_vars = self.load_dotenv()

        # Check if all variables are defined
        content = source.read_text()
        required_vars = set(self.PATTERN.findall(content))
        missing_vars = [v for v in required_vars if not env_vars.get(v)]

        if missing_vars:
            print(
                f"  {yellow('‚ö†Ô∏è  Skipped:')} {source.name} - missing vars: {', '.join(missing_vars)}"
            )
            return None

        # Render template
        for key, value in env_vars.items():
            content = content.replace(f"#{{{key}}}", value)

        # Write generated file
        generated_path = source.with_suffix("")  # Remove .example
        generated_path.write_text(content)

        return generated_path


# ==============================================================================
# Configuration Manager
# ==============================================================================


class ConfigManager:
    """Manage dotfiles.json configuration"""

    def __init__(self, dotfiles_dir: Path):
        self.dotfiles_dir = dotfiles_dir
        self.config_file = dotfiles_dir / "dotfiles.json"

    def load(self, validate: bool = False) -> Tuple[List[DotfileEntry], List[Dict]]:
        """Load dotfile entries, optionally validate and clean
        Returns: (valid_entries, removed_entries)
        """
        if not self.config_file.exists():
            return [], []

        with open(self.config_file) as f:
            config = json.load(f)

        entries = []
        removed = []

        for item in config.get("dotfiles", []):
            # Validate source exists
            source_path = self.dotfiles_dir / item["source"]

            if validate and not source_path.exists():
                removed.append(item)
                continue

            entries.append(
                DotfileEntry(
                    source=item["source"],
                    target=item["target"],
                    type=item.get("type", "file"),
                    template=item.get("template", False),
                )
            )

        # Save cleaned config if entries were removed
        if removed:
            self.save(entries)

        return entries, removed

    def save(self, entries: List[DotfileEntry]):
        """Save dotfile entries"""
        config = {
            "dotfiles": [
                {
                    "source": e.source,
                    "target": e.target,
                    "type": e.type,
                    **({"template": True} if e.template else {}),
                }
                for e in entries
            ]
        }

        with open(self.config_file, "w") as f:
            json.dump(config, f, indent=2)

    def add(self, entry: DotfileEntry):
        """Add a new entry"""
        entries, _ = self.load()

        # Check duplicates
        for e in entries:
            if e.source == entry.source:
                raise ValueError(f"Source already exists: {entry.source}")
            if e.target == entry.target:
                raise ValueError(f"Target already exists: {entry.target}")

        entries.append(entry)
        self.save(entries)


# ==============================================================================
# Symlink Manager
# ==============================================================================


class Linker:
    """Manage symlinks"""

    def __init__(self, dotfiles_dir: Path, template_manager: TemplateManager):
        self.dotfiles_dir = dotfiles_dir
        self.template_manager = template_manager
        self.backup_dir = dotfiles_dir / ".dot" / "backup"

    def check_status(self, entry: DotfileEntry) -> LinkStatus:
        """Check symlink status"""
        target = Path(entry.target).expanduser()
        source = self._get_source_path(entry)

        if not target.exists() and not target.is_symlink():
            return LinkStatus.MISSING

        if target.is_symlink():
            link_target = target.resolve()
            if link_target == source.resolve():
                return LinkStatus.OK
            else:
                return LinkStatus.BROKEN

        # Path exists but is not a symlink
        return LinkStatus.CONFLICT

    def link(self, entry: DotfileEntry, force: bool = False) -> str:
        """Create symlink"""
        target = Path(entry.target).expanduser()
        source = self._get_source_path(entry)

        # Handle template rendering
        if entry.template and entry.source.endswith(".example"):
            rendered = self.template_manager.render_template(
                self.dotfiles_dir / entry.source
            )
            if rendered:
                source = rendered
            else:
                return "template error"

        # Validate source exists
        if not source.exists():
            raise FileNotFoundError(f"Source does not exist: {source}")

        # Check current status
        status = self.check_status(entry)

        if status == LinkStatus.OK:
            return "already linked"

        # Handle conflicts
        if status == LinkStatus.CONFLICT:
            if not force:
                raise FileExistsError(f"Target exists and is not a symlink: {target}")

            # Backup existing file/dir
            self._backup(target)

        # Handle broken symlinks
        if status == LinkStatus.BROKEN:
            target.unlink()

        # Create parent directories
        target.parent.mkdir(parents=True, exist_ok=True)

        # Create symlink
        target.symlink_to(source)
        return "linked"

    def unlink(self, entry: DotfileEntry) -> str:
        """Remove symlink"""
        target = Path(entry.target).expanduser()

        if not target.exists() and not target.is_symlink():
            return "not found"

        if not target.is_symlink():
            return "not a symlink"

        target.unlink()
        return "unlinked"

    def _get_source_path(self, entry: DotfileEntry) -> Path:
        """Get actual source path (handles template rendering)"""
        source = self.dotfiles_dir / entry.source

        # If template, use generated file instead
        if entry.template and source.name.endswith(".example"):
            generated = source.with_suffix("")
            if generated.exists():
                return generated

        return source

    def _backup(self, path: Path):
        """Backup existing file/dir"""
        from datetime import datetime

        self.backup_dir.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{path.name}.{timestamp}"
        backup_path = self.backup_dir / backup_name

        if path.is_dir():
            shutil.copytree(path, backup_path, symlinks=True)
            shutil.rmtree(path)
        else:
            shutil.copy2(path, backup_path)
            path.unlink()

        print(f"  {yellow('‚ö†Ô∏è  Backed up:')} {backup_path}")


# ==============================================================================
# CLI Application
# ==============================================================================


class DotApp:
    """Main application"""

    DOTRC_PATH = Path.home() / ".dotrc"

    def __init__(self, dotfiles_dir: Optional[Path] = None):
        if dotfiles_dir is None:
            dotfiles_dir = self._find_dotfiles_dir()

        self.dotfiles_dir = dotfiles_dir.expanduser().resolve()
        self.config = ConfigManager(self.dotfiles_dir)
        self.template_manager = TemplateManager(self.dotfiles_dir)
        self.linker = Linker(self.dotfiles_dir, self.template_manager)

    @staticmethod
    def _find_dotfiles_dir() -> Path:
        """Find dotfiles directory"""
        # 1. Check environment variable
        if env_dir := os.environ.get("DOTFILES_DIR"):
            return Path(env_dir).expanduser()

        # 2. Check ~/.dotrc
        if DotApp.DOTRC_PATH.exists():
            with open(DotApp.DOTRC_PATH) as f:
                return Path(f.read().strip()).expanduser()

        # 3. Auto-detect from script location
        script_dir = Path(sys.argv[0]).parent.resolve()
        return script_dir.parent

    def cmd_init(self):
        """Initialize dotfiles management"""
        print(f"\n{bold('üöÄ Initializing dot...')}\n")

        # Save dotfiles directory
        with open(self.DOTRC_PATH, "w") as f:
            f.write(str(self.dotfiles_dir))
        print(f"{green('‚úì')} Saved dotfiles directory to {self.DOTRC_PATH}")
        print(f"  {dim(f'Location: {self.dotfiles_dir}')}\n")

        # Create config if missing
        if not self.config.config_file.exists():
            self.config.save([])
            print(f"{green('‚úì')} Created dotfiles.json\n")
        else:
            # Validate and clean existing config
            entries, removed = self.config.load(validate=True)

            if removed:
                print(f"{yellow('‚ö†Ô∏è  Cleaned dotfiles.json:')}")
                for item in removed:
                    print(
                        f"  {red('‚úó')} Removed: {cyan(item['source'])} - source not found"
                    )
                print()

        # Scan templates and update .dotenv
        print(f"{blue('üîç Scanning templates...')}")
        variables = self.template_manager.scan_templates()

        if variables:
            print(f"  Found {len(variables)} variables: {', '.join(sorted(variables))}")

            added = self.template_manager.update_dotenv(variables)
            if added:
                print(f"{green('‚úì')} Added {added} variables to .dotenv")
                print(f"  {dim('Please edit .dotenv to fill in values')}")
            else:
                print(f"{green('‚úì')} .dotenv is up to date")
        else:
            print(f"  {dim('No templates found')}")

        print()
        print(f"{bold(green('‚úì Ready to use!'))}")
        print(f"\nNext steps:")
        print(f"  1. {cyan('edit .dotenv')} to set template variables")
        print(f"  2. {cyan('dot add <source>')} to add files")
        print(f"  3. {cyan('dot link')} to create symlinks")

    def cmd_add(self, source: str, target: Optional[str] = None):
        """Add file to management"""
        source_path = self.dotfiles_dir / source

        # Validate source exists
        if not source_path.exists():
            print(f"{red('‚ùå Error:')} Source does not exist: {source}")
            return

        # Auto-detect type
        file_type = "dir" if source_path.is_dir() else "file"

        # Auto-generate target
        if target is None:
            filename = source_path.name
            # Remove .example suffix for target
            if filename.endswith(".example"):
                filename = filename[:-8]  # Remove .example

            if not filename.startswith("."):
                filename = f".{filename}"
            target = f"~/{filename}"

        # Auto-detect template (only .example files are templates)
        template = source.endswith(".example")
        if template:
            print(f"{blue('‚ÑπÔ∏è  Auto-detected as template')}")

        # Create entry
        entry = DotfileEntry(
            source=source, target=target, type=file_type, template=template
        )

        try:
            self.config.add(entry)

            print(f"\n{green('‚úì')} Added to dotfiles.json")
            print(f"  Source:   {cyan(source)}")
            print(f"  Target:   {cyan(target)}")
            print(f"  Type:     {file_type}")
            if template:
                print(f"  Template: {yellow('yes')}")
            print(f"\nNext: {cyan('dot link')} to create symlinks")

        except ValueError as e:
            print(f"{red('‚ùå Error:')} {e}")

    def cmd_link(self, force: bool = False, quiet: bool = False):
        """Create all symlinks"""
        # Load and validate config
        entries, removed = self.config.load(validate=True)

        if removed and not quiet:
            print(f"\n{yellow('‚ö†Ô∏è  Warning: Cleaned invalid entries:')}")
            for item in removed:
                print(f"  {red('‚úó')} {item['source']} - source not found")
            print()

        if not entries:
            if not quiet:
                print(f"{yellow('No files to link')}")
                print(f"Add files with: {cyan('dot add <source>')}")
            return

        if not quiet:
            print(f"\n{bold('Creating symlinks...')}\n")

        success = 0
        already_linked = 0
        errors = []
        template_errors = []

        for entry in entries:
            try:
                result = self.linker.link(entry, force=force)

                if result == "linked":
                    if not quiet:
                        print(f"{green('‚úì')} {entry.target}")
                    success += 1
                elif result == "already linked":
                    if not quiet:
                        print(f"{dim('‚óã')} {entry.target} {dim('(already linked)')}")
                    already_linked += 1
                elif result == "template error":
                    template_errors.append(entry)

            except Exception as e:
                if not quiet:
                    print(f"{red('‚úó')} {entry.target}")
                    print(f"  {red(f'Error: {e}')}")
                errors.append((entry, str(e)))

        # Summary
        if quiet:
            # Compact summary for sync
            changes = []
            if success > 0:
                changes.append(f"+{success}")
            if errors:
                changes.append(f"-{len(errors)}")

            if changes:
                print(f"{green('‚úì')} Symlinks updated ({', '.join(changes)})")
            else:
                print(f"{green('‚úì')} Symlinks up to date")

            if template_errors:
                print(f"  {yellow('‚ö†Ô∏è ')} {len(template_errors)} templates skipped")
        else:
            # Detailed summary for direct link command
            print(f"\n{bold('Summary:')}")
            if success > 0:
                print(f"  {green('‚úì')} {success} linked")
            if template_errors:
                print(
                    f"  {yellow('‚ö†Ô∏è ')} {len(template_errors)} templates skipped (missing variables)"
                )
                print(f"      Run {cyan('dot init')} and edit .dotenv")
            if errors:
                print(f"  {red('‚úó')} {len(errors)} failed")
                print(f"\nTip: Use {cyan('dot link --force')} to backup and overwrite")

    def cmd_unlink(self):
        """Remove all symlinks"""
        entries, _ = self.config.load()

        if not entries:
            print(f"{yellow('No files to unlink')}")
            return

        print(f"\n{bold('Removing symlinks...')}\n")

        for entry in entries:
            result = self.linker.unlink(entry)

            if result == "unlinked":
                print(f"{green('‚úì')} {entry.target}")
            elif result == "not found":
                print(f"{dim('‚óã')} {entry.target} {dim('(not found)')}")
            elif result == "not a symlink":
                print(f"{yellow('‚ö†Ô∏è ')} {entry.target} {yellow('(not a symlink)')}")

    def cmd_status(self):
        """Check symlink status and list managed files"""
        # Load and validate config
        entries, removed = self.config.load(validate=True)

        if removed:
            print(f"\n{yellow('‚ö†Ô∏è  Warning: Removed invalid entries:')}")
            for item in removed:
                print(f"  {red('‚úó')} {item['source']} - source not found")
            print()

        if not entries:
            print(f"{yellow('No managed files')}")
            return

        print(f"\n{bold('Managed files')} ({len(entries)}):\n")

        status_map = {
            LinkStatus.OK: (green("‚úì"), "OK"),
            LinkStatus.MISSING: (yellow("‚óã"), "Not linked"),
            LinkStatus.BROKEN: (red("‚úó"), "Broken link"),
            LinkStatus.CONFLICT: (yellow("‚ö†Ô∏è "), "Conflict"),
        }

        for entry in entries:
            status = self.linker.check_status(entry)
            symbol, label = status_map[status]

            tmpl_flag = yellow(" [T]") if entry.template else ""
            print(
                f"{symbol} {cyan(entry.source)}{tmpl_flag} ‚Üí {entry.target} {dim(f'({label})')}"
            )

        print(f"\nRun {cyan('dot link')} to create missing symlinks")

    def _run_cmd(self, name: str, cmd: List[str], success_msg: str) -> bool:
        """Run a command and print status"""
        import subprocess

        try:
            result = subprocess.run(
                cmd, cwd=self.dotfiles_dir, capture_output=True, text=True, check=True
            )
            print(f"{green('‚úì')} {success_msg}")
            if result.stdout.strip() and cmd[0] == "git":
                print(f"  {dim(result.stdout.strip())}")
            return True
        except subprocess.CalledProcessError as e:
            print(f"{yellow('‚ö†Ô∏è  Failed:')} {e.stderr.strip() if e.stderr else str(e)}")
            return False
        except FileNotFoundError:
            print(f"{yellow('‚ö†Ô∏è  Command not found:')} {cmd[0]}")
            return False

    def cmd_sync(self, force: bool = False):
        """Sync everything: git pull + brew + mise + link"""
        print(f"\n{bold('üîÑ Syncing dotfiles...')}\n")

        # 1. Git pull
        print(f"{blue('üì• Updating repository...')}")
        self._run_cmd("git", ["git", "pull"], "Repository updated")
        print()

        # 2. Homebrew
        if (self.dotfiles_dir / "Brewfile").exists():
            print(f"{blue('üç∫ Installing Homebrew packages...')}")
            self._run_cmd(
                "brew",
                ["brew", "bundle", "install", "--upgrade", "--file=Brewfile"],
                "Homebrew packages updated",
            )
            print()

        # 3. Mise
        if (self.dotfiles_dir / "tools" / "mise" / "mise.toml").exists():
            print(f"{blue('üî® Installing mise tools...')}")
            self._run_cmd("mise", ["mise", "install"], "Mise tools updated")
            print()

        # 4. Link dotfiles
        print(f"{blue('üîó Linking dotfiles...')}")
        self.cmd_link(force=force)

        print(f"\n{bold(green('‚úì Sync complete!'))}")


# ==============================================================================
# CLI Entry Point
# ==============================================================================


def create_parser() -> argparse.ArgumentParser:
    """Create CLI parser"""
    parser = argparse.ArgumentParser(
        description="dot - Symlink-based dotfiles manager",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("--dir", type=Path, help="Dotfiles directory")

    subparsers = parser.add_subparsers(dest="command", title="commands")

    # init
    subparsers.add_parser("init", help="Initialize dotfiles management")

    # add
    add_parser = subparsers.add_parser("add", help="Add file to management")
    add_parser.add_argument("source", help="Source path (relative to dotfiles dir)")
    add_parser.add_argument(
        "target", nargs="?", help="Target path (default: ~/.<source>)"
    )

    # link
    link_parser = subparsers.add_parser("link", help="Create all symlinks")
    link_parser.add_argument(
        "--force", action="store_true", help="Backup and overwrite existing files"
    )

    # unlink
    subparsers.add_parser("unlink", help="Remove all symlinks")

    # status
    subparsers.add_parser("status", help="Show managed files and symlink status")

    # sync
    sync_parser = subparsers.add_parser(
        "sync", help="Sync everything (git pull + brew + mise + link)"
    )
    sync_parser.add_argument(
        "--force", action="store_true", help="Force overwrite existing files"
    )

    return parser


def main():
    """Main entry point"""
    parser = create_parser()
    args = parser.parse_args()

    # Default to sync if no command specified
    if not args.command:
        args.command = "sync"
        args.force = False

    try:
        app = DotApp(args.dir)

        if args.command == "init":
            app.cmd_init()
        elif args.command == "add":
            app.cmd_add(args.source, args.target)
        elif args.command == "link":
            app.cmd_link(force=args.force)
        elif args.command == "unlink":
            app.cmd_unlink()
        elif args.command == "status":
            app.cmd_status()
        elif args.command == "sync":
            app.cmd_sync(force=args.force)

    except Exception as e:
        print(f"\n{red('‚ùå Error:')} {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
